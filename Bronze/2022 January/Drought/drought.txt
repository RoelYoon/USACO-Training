/*
ID: roelyoon
TASK: drought
LANG: C++    
*/
#include <stdio.h>
#include <memory>
#include <vector> 
#include <unordered_map>
#define PARENT(i) (i-1)/2
#define LEFT(i) (2*i)+1
#define RIGHT(i) (2*i)+2
typedef long long ll;
using namespace std;
struct element{
    shared_ptr<element> left,right;
    ll value;
    int key; 
};
struct binary_heap{
    vector<shared_ptr<element>> pq; 
    unordered_map<int, int> keyToIndex;
    shared_ptr<element> top(){
        return pq[0];
    }
    shared_ptr<element> updatePair(ll min,ll &count){
        shared_ptr<element> pair;
        if(pq[0]->left==NULL){pair=pq[0]->right;}
        else if(pq[0]->right==NULL){pair=pq[0]->left;}
        else{pair = (pq[0]->left->value>pq[0]->right->value) ? pq[0]->left : pq[0]->right;}
        ll update = pq[0]->value - min;
        pq[0]->value-=update;
        pair->value-=update;
        count+=update*2;
        return pair; 
    }
    void swap(shared_ptr<element> a, shared_ptr<element> b){
        int indA = keyToIndex[a->key];
        int indB = keyToIndex[b->key];
        keyToIndex[a->key]=indB;
        keyToIndex[b->key]=indA;
        shared_ptr<element> temp = pq[indB];
        pq[indB] = pq[indA];
        pq[indA] = temp; 
    }
    void siftDown(shared_ptr<element> item){
        int i=keyToIndex[item->key],leftI, rightI;
        while(true){
            leftI=LEFT(i);
            rightI=RIGHT(i);
            if(leftI>pq.size()-1 && rightI>pq.size()-1){break;}
            else if(leftI>pq.size()-1&&pq[rightI]->value>=pq[i]->value){swap(pq[i],pq[rightI]);i=rightI;}
            else if(rightI>pq.size()-1&&pq[leftI]->value>=pq[i]->value){swap(pq[i],pq[leftI]);i=leftI;}
            else if(leftI<pq.size()&&rightI<pq.size()&&pq[leftI]->value>pq[rightI]->value &&pq[leftI]->value>=pq[i]->value){swap(pq[i],pq[leftI]);i=leftI;}
            else if(leftI<pq.size()&&rightI<pq.size()&&pq[rightI]->value>=pq[leftI]->value &&pq[rightI]->value>=pq[i]->value){swap(pq[i],pq[rightI]);i=rightI;}
            else{break;}
        }
    }
    void insert(shared_ptr<element> item){
        pq.push_back(item);
        int i = pq.size()-1, parent; 
        keyToIndex[item->key]=i;
        while(true){
            parent = PARENT(i);
            if(pq[i]->value>pq[parent]->value){
                swap(pq[i],pq[parent]);
                i=parent;
            }else{break;}
            if(i==0){break;}
        }
        keyToIndex[item->key]=i;
    }
};
int main(){
    int t;
    scanf("%d",&t);
    for(int test = 0; test<t; test++){
        int n;
        ll count = 0; 
        scanf("%d",&n);
        vector<shared_ptr<element>> hungerList(n); 
        binary_heap heap;
        for(int i = 0; i < n; i++){
            shared_ptr<element> temp(new element);
            scanf("%lld",&(temp->value));
            temp->key=i;
            hungerList[i]=temp;
        } if(n==1){printf("0\n");continue;}
        for(int i = 0; i < n; i++){
            shared_ptr<element> temp = hungerList[i]; 
            if(i!=0){temp->left = hungerList[i-1];}
            else{temp->left=NULL;}
            if(i!=n-1){temp->right = hungerList[i+1];}
            else{temp->right=NULL;}
            heap.insert(temp);
        }
        ll min = hungerList[0]->value;
        for(int i = 1; i < n; i++){
            if(hungerList[i]->value<min){
                min=hungerList[i]->value;
            }
        }
        ll trueMin = min;
        while(true){
            shared_ptr<element> pair = heap.updatePair(min,count);
            if(pair->value < trueMin){
                trueMin=pair->value;
            }
            if(trueMin<0){
                count=-1;
                break;
            }
            heap.siftDown(pair);
            heap.siftDown(heap.top());
            if(heap.top()->value==min){min=trueMin;}
            if(heap.top()->value==trueMin){break;}
        }
        printf("%lld\n",count);
    }
}